Configuration Guide
Basic Settings
python
config = AppConfig(
    model_path=Path("path/to/your/model"),
    camera_index=0,  # Change for different cameras
    frame_width=1280,  # Higher resolution
    frame_height=720,
    confidence_threshold=0.7  # More strict detection
)
Class-Specific Settings
python
# Custom colors for different classes
class_color_map={0: (255, 0, 0), 1: (0, 255, 0), 2: (0, 0, 255)}

# Different cooldowns per class (in seconds)
class_cooldowns={0: 10, 1: 5, 2: 15, 3: 8}
Usage Examples
1. Basic Usage
python
# Default configuration
detector = ObjectDetector(AppConfig())
detector.run()
2. Custom Configuration
python
config = AppConfig(
    model_path=Path("custom_model.torchscript"),
    class_color_map={0: (255, 255, 0), 1: (0, 255, 255)},
    class_cooldowns={0: 15, 1: 3}
)
detector = ObjectDetector(config)
detector.run()
Extensibility Points
1. Adding New Classes
Update model with new classes

Add to class_color_map with desired color

Add to class_cooldowns with alert frequency

2. Custom Alert Logic
Override should_trigger_alert() method in AlertManager for:

Count-based alerts (alert after N detections)

Position-based alerts (only alert for objects in certain areas)

Combination rules (alert when multiple classes detected)

3. Additional Visualizations
Extend DetectionVisualizer with new methods for:

Heatmaps of detection frequency

Historical tracking visualizations

Custom information panels

Performance Considerations
1. Frame Processing Rate
Default resolution: 640Ã—480 (optimal for real-time)

Higher resolutions will reduce FPS

Consider hardware capabilities when increasing resolution

2. Alert Management
Cooldowns prevent audio spam

Threaded audio prevents blocking main detection loop

3. Memory Usage
Model loaded once at initialization

Frame processing uses minimal additional memory

Troubleshooting Guide
Common Issues
Webcam not found: Check camera_index (try 0, 1, 2)

Model loading error: Verify model path and format

Audio not playing: Check file path and PyGame installation

Low FPS: Reduce resolution or confidence threshold

Debug Mode
Add debug prints to key methods to monitor:

Frame processing time

Detection counts

Alert triggering

Future Expansion Capabilities
Immediate Additions
Multiple Camera Support: Modify setup_camera() to handle multiple sources

Recording Functionality: Add frame capture on detection events

Network Streaming: Implement RTSP or HTTP streaming output

Advanced Features
Object Tracking: Add persistence between frames

Cross-Line Detection: Alert when objects cross virtual lines

REST API: Add HTTP endpoints for configuration and status

Cloud Integration: Send alerts and metrics to cloud services


---


If want to change the display when using the rtsp connect, uncomment this lines
```
        # Resize the frame 
        # frame = cv2.resize(frame, (1024, 576)) # Change this to resize the window
```

and comment / uncomment this code if want to change between video / rtsp

```
    # Configuration - change only these values to modify application behavior
    
    # For webcam (default)
    camera_source = 0
    
    # For RTSP stream (uncomment and modify as needed)
    #camera_source = "rtsp://admin:CemaraMas2025!@192.168.2.190:554/Streaming/Channels/101"
    
    # Try different camera indices if 0 doesn't work
    for camera_idx in [0, 1, 2]:
        try:
            test_cap = cv2.VideoCapture(camera_idx)
            if test_cap.isOpened():
                print(f"Found camera at index {camera_idx}")
                test_cap.release()
                camera_source = camera_idx
                break
        except:
            pass
```


Here is what we could do so far:

Fundamental Capabilities Summary
Core Functionality
Your code is a modular real-time object detection system with these capabilities:

1. Video Source Flexibility
Works with webcams (camera index 0, 1, 2, etc.)

Supports RTSP streams (network cameras)

Automatic camera discovery and reconnection

2. Object Detection
Uses YOLOv8 model for accurate detection

Configurable confidence threshold (0.5 by default)

Custom-trained model support (.torchscript format)

3. Smart Counting System
Real-time frame counts (detections per frame)

Time-based cumulative counts (e.g., last 10 seconds)

Automatic count expiration after time window

4. Alert System
Audio alerts with configurable sound

Class-specific cooldowns (different timing per object type)

Non-blocking audio (doesn't affect detection performance)

5. Visual Interface
Bounding boxes with labels and confidence scores

Dual-panel display:

Top-left: Alert cooldown status

Top-right: Detection counters

Connection status indicator

Error messages overlay when needed

6. Configuration Management
Centralized settings in AppConfig class

Easy to modify:

Camera source

Detection thresholds

Alert preferences

Time windows

Type-safe configuration with dataclasses

7. Robust Error Handling
Automatic reconnection for RTSP streams

Graceful degradation when camera unavailable

Detailed error messages for troubleshooting

Technical Foundation
Modular architecture (separate classes for each responsibility)

Thread-safe operations (audio in separate threads)

Memory efficient (time-based counter with rolling window)

OpenCV-based video processing

PyGame for audio alerts

Use Cases Supported
Real-time security monitoring

Object counting applications

Network camera integration

Custom detection scenarios

Both local and remote camera sources


System Architecture
<ol>1. Configuration Management (AppConfig Class)</ol>
Purpose: Centralizes all application settings for easy modification

```Python
@dataclass
class AppConfig:
    # Model configuration
    model_path: Path = Path("path/to/model")
    # Webcam configuration  
    camera_index: int = 0
    frame_width: int = 640
    frame_height: int = 480
    # Detection configuration
    confidence_threshold: float = 0.5
    class_color_map: Dict[int, Tuple[int, int, int]] = None
    # Alert configuration
    alert_sound_path: Path = Path("path/to/sound")
    alert_cooldown: int = 5
    class_cooldowns: Dict[int, int] = None
```
<ol>2. Alert Management (AlertManager Class)</ol>
Purpose: Handles audio alerts with class-specific cooldowns

<li>Key Methods:</li>

<ul>1. should_trigger_alert(cls_id): Checks if alert should play based on cooldown</ul>
<ul>2. play_alert(): Plays sound in non-blocking thread</ul>


<ol>3. Visualization Engine (DetectionVisualizer Class)</ol>
Purpose: Manages all visual elements of the detection system

<li>Key Methods:</li>

<ul>draw_detection(): Draws bounding boxes and labels</ul>
<ul>draw_text_panel(): Creates information overlay</ul>
<ul>draw_cooldown_status(): Shows alert cooldown timers</ul>


<ol>4. Core Detection Pipeline (ObjectDetector Class)</ol>
Purpose: Main orchestrator that ties all components together

Key Methods:

<ul>setup_camera(): Initializes webcam with configured settings</ul>

<ul>process_frame(): Runs detection on each frame and manages alerts</ul>

<ul>run(): Main application loop</ul>

Configuration Guide
Basic Settings

```Python
config = AppConfig(
    model_path=Path("path/to/your/model"),
    camera_index=0,  # Change for different cameras
    frame_width=1280,  # Higher resolution
    frame_height=720,
    confidence_threshold=0.7  # More strict detection
)
```
Class-Specific Settings
```python
# Custom colors for different classes
class_color_map={0: (255, 0, 0), 1: (0, 255, 0), 2: (0, 0, 255)}

# Different cooldowns per class (in seconds)
class_cooldowns={0: 10, 1: 5, 2: 15, 3: 8}
```
Usage Examples
1. Basic Usage
```python
# Default configuration
detector = ObjectDetector(AppConfig())
detector.run()
```

2. Custom Configuration
```python
config = AppConfig(
    model_path=Path("custom_model.torchscript"),
    class_color_map={0: (255, 255, 0), 1: (0, 255, 255)},
    class_cooldowns={0: 15, 1: 3}
)
detector = ObjectDetector(config)
detector.run()
```
